// This file is part of the re-motion Core Framework (www.re-motion.org)
// Copyright (C) 2005-2009 rubicon informationstechnologie gmbh, www.rubicon.eu
// 
// The re-motion Core Framework is free software; you can redistribute it 
// and/or modify it under the terms of the GNU Lesser General Public License 
// as published by the Free Software Foundation; either version 2.1 of the 
// License, or (at your option) any later version.
// 
// re-motion is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with re-motion; if not, see http://www.gnu.org/licenses.
// 
using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Remotion.Data.Linq.Parsing.ExpressionTreeVisitors;
using Remotion.Data.Linq.Utilities;

namespace Remotion.Data.Linq.Parsing.Structure.IntermediateModel
{
  /// <summary>
  /// Represents a <see cref="MethodCallExpression"/> for the different <see cref="O:Queryable.GroupBy"/> 
  /// overloads that do take a result selector. The overloads without a result selector are represented by 
  /// <see cref="GroupByExpressionNode"/>.
  /// It is generated by <see cref="ExpressionTreeParser"/> when an <see cref="Expression"/> tree is parsed.
  /// </summary>
  /// <remarks>
  /// The GroupBy overloads with result selector are parsed as if they were a <see cref="SelectExpressionNode"/> following a 
  /// <see cref="GroupByExpressionNode"/>:
  /// <code>
  /// x.GroupBy (k => key, e => element, (k, g) => result)
  /// </code>
  /// is therefore equivalent to:
  /// <code>
  /// c.GroupBy (k => key, e => element).Select (grouping => resultSub)
  /// </code>
  /// where resultSub is the same as result with k and g substituted with grouping.Key and grouping, respectively.
  /// </remarks>
  public class GroupByWithResultSelectorExpressionNode : SelectExpressionNode, IQuerySourceExpressionNode
  {
    public new static readonly MethodInfo[] SupportedMethods = new[]
                                                           {
                                                               GetSupportedMethod (() => Queryable.GroupBy<object, object, object, object> (null, o => null, o => null, (k, g) => null)),
                                                               GetSupportedMethod (() => Enumerable.GroupBy<object, object, object, object> (null, o => null, o => null, (k, g) => null)),
                                                           };

    public GroupByWithResultSelectorExpressionNode (
        MethodCallExpressionParseInfo parseInfo, 
        LambdaExpression keySelector, 
        LambdaExpression elementSelector, 
        LambdaExpression resultSelector)
      : base (CreateParseInfoWithGroupNode (
          parseInfo, 
          ArgumentUtility.CheckNotNull ("keySelector", keySelector), 
          ArgumentUtility.CheckNotNull ("elementSelector", elementSelector)), 
          CreateSelectorForSelectNode (
              ArgumentUtility.CheckNotNull ("resultSelector", resultSelector), 
              keySelector.Body.Type,
              elementSelector.Body.Type))
    {
    }

    private static MethodCallExpressionParseInfo CreateParseInfoWithGroupNode (MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector, LambdaExpression elementSelector)
    {
      var groupBySourceNode = new GroupByExpressionNode (parseInfo, keySelector, elementSelector);
      return new MethodCallExpressionParseInfo (
          parseInfo.AssociatedIdentifier,
          groupBySourceNode, 
          parseInfo.ParsedExpression);
    }

    private static LambdaExpression CreateSelectorForSelectNode (LambdaExpression resultSelector, Type keyType, Type elementType)
    {
      if (resultSelector.Parameters.Count != 2)
        throw new ArgumentException ("ResultSelector must have exactly two parameters.", "resultSelector");

      var groupingType = typeof (IGrouping<,>).MakeGenericType (keyType, elementType);
      var keyProperty = groupingType.GetProperty ("Key");

      var groupParameter = Expression.Parameter (groupingType, "group");
      var keyExpression = Expression.MakeMemberAccess (groupParameter, keyProperty);
      var bodyWithGroupingReplaced = ReplacingExpressionTreeVisitor.Replace (resultSelector.Parameters[1], groupParameter, resultSelector.Body);
      var bodyWithGroupingAndKeyReplaced = ReplacingExpressionTreeVisitor.Replace (resultSelector.Parameters[0], keyExpression, bodyWithGroupingReplaced);
      return Expression.Lambda (bodyWithGroupingAndKeyReplaced, groupParameter);
    }

  }
}
